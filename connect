import csv
import re
from traceback import print_stack
from typing import List, Tuple, Dict, Any

import redis

try:
    from redis.commands.search.query import Query
    from redis.commands.search.field import TextField, NumericField, TagField
    from redis.commands.search.indexDefinition import IndexDefinition

    SEARCH_AVAILABLE = True
except ImportError:
    SEARCH_AVAILABLE = False

    
    Query = TextField = NumericField = TagField = IndexDefinition = object  # type: ignore


class RedisClient:

    def __init__(
        self,
        host: str = "localhost",
        port: int = 6379,
        db: int = 0,
        username: str | None = None,
        password: str | None = None,
    ):
        self._r: redis.Redis | None = None
        self._redis_settings = dict(
            host=host,
            port=port,
            db=db,
            username=username,
            password=password,
            decode_responses=True,
        )
        self._search_enabled = False 

    def connect(self) -> None:
        
        try:
            print("Connecting to Redis …", end="")
            self._r = redis.Redis(**self._redis_settings)
            self._r.ping()
            print(" connected")
        except Exception as exc:
            print("not connected")
            print_stack()
            raise exc

    def load_users(self, file: str = "users.txt") -> int:
        
        if self._r is None:
            raise RuntimeError("connect() first")

        count = 0
        pipe  = self._r.pipeline()

        if file.lower().endswith(".csv"):
            
            with open(file, newline="", encoding="utf-8") as fh:
                reader = csv.DictReader(fh)
                for row in reader:
                    raw = row.pop("id", row.pop("user:id", None))
                    if raw is None:
                        raise ValueError(
                            "CSV must contain either 'id' or 'user:id' column.")
                    uid  = raw.split(":", 1)[-1]
                    key  = f"user:{uid}"
                    for f, v in row.items():
                        pipe.hset(key, f, v)
                    count += 1
        else:
           
            import re
            pattern = re.compile(r'"([^"]*)"')  

            with open(file, encoding="utf-8") as fh:
                for line in fh:
                    tokens = pattern.findall(line)
                    if not tokens:
                        continue     
                    raw_uid = tokens[0]          
                    uid     = raw_uid.split(":", 1)[-1]
                    key     = f"user:{uid}"

                    for i in range(1, len(tokens), 2):
                        field = tokens[i]
                        value = tokens[i + 1] if i + 1 < len(tokens) else ""
                        pipe.hset(key, field, value)
                    count += 1

        pipe.execute()
        print(f"Loaded {count} users from {file}.")
        self._ensure_secondary_index()
        return count


    def load_scores(self, file: str = "scores.csv") -> int:
        
        if self._r is None:
            raise RuntimeError("connect() first")

        with open(file, newline="", encoding="utf-8") as fh:
            reader = csv.DictReader(fh)
            pipe = self._r.pipeline()
            count = 0
            for row in reader:
                uid = row["user:id"].split(":", 1)[-1]
                score = float(row["score"])
                lb = row["leaderboard"]
                pipe.zadd(f"leaderboard:{lb}", {uid: score})
                count += 1
            pipe.execute()

        print(f"Loaded {count} scores.")
        return count

    def query1(self, usr: int | str) -> Dict[str, str]:
        return self._r.hgetall(f"user:{usr}") if self._r else {}

    def query2(self, usr: int | str) -> tuple[float, float] | None:
        
        print("Executing query2 …")
        h = self._r.hgetall(f"user:{usr}")
        if not h:
            return None

        try:
            return float(h["longitude"]), float(h["latitude"])
        except KeyError:
            print(f"'longitude' or 'latitude' missing for user:{usr}")
            return None


    def query3(self) -> List[Tuple[str, str]]:
        
        if self._r is None:
            return []

        cursor = 1280
        pattern = "user:*"
        out: List[Tuple[str, str]] = []
        while True:
            cursor, keys = self._r.scan(cursor=cursor, match=pattern, count=100)
            for key in keys:
                uid = key.split(":", 1)[1]
                if re.match(r"^[13579]", uid):
                    continue
                out.append((uid, self._r.hget(key, "last_name")))
            if cursor == 0:
                break
        return out

    def query4(self) -> List[Any]:
    
        if self._search_enabled:
            q = (
                Query("@gender:female @country:{China|Russia} @latitude:[40 46]")
                .return_fields("first_name", "last_name", "country", "latitude")
                .paging(0, 100)
            )
            return self._r.ft("idx:users").search(q).docs  # type: ignore[attr-defined]

        print("(RediSearch unavailable due to libraries not found → scanning manually)")
        results: List[Any] = []
        for key in self._r.scan_iter("user:*"):
            h = self._r.hgetall(key)
            lat = float(h.get("latitude", "0"))
            if (
                h.get("gender", "").lower() == "female"
                and h.get("country") in ("China", "Russia")
                and 40 <= lat <= 46
            ):
                results.append(
                    {
                        "id": key.split(":", 1)[1],
                        "first_name": h.get("first_name"),
                        "last_name": h.get("last_name"),
                        "country": h.get("country"),
                        "latitude": lat,
                    }
                )
        return results

    def query5(self) -> List[str]:
       
        if self._r is None:
            return []
        top10 = self._r.zrevrange("leaderboard:2", 0, 9)
        pipe = self._r.pipeline()
        for uid in top10:
            pipe.hget(f"user:{uid}", "email")
        return pipe.execute()
    
    def _ensure_secondary_index(self) -> None:
        
        if not SEARCH_AVAILABLE:
            print("RediSearch Python symbols missing – query4 will use SCAN.")
            return

        try:
            self._r.ft("idx:users").info()          
            self._search_enabled = True
        except Exception:
            try:
                schema = [
                    TextField("first_name"),
                    TextField("gender"),
                    TagField("country"),
                    NumericField("latitude"),
                ]
                idx_def = IndexDefinition(prefix=["user:"])
                self._r.ft("idx:users").create_index(schema, definition=idx_def)  
                print("Created RediSearch index idx:users.")
                self._search_enabled = True
            except Exception as e:
                print(f"Cannot create RediSearch index ({e}). Falling back to SCAN.")
                self._search_enabled = False



if __name__ == "__main__":
    rc = RedisClient()  
    rc.connect()

  
    rc.load_users(r"users.txt")
    rc.load_scores(r"userscores.csv")

    print("query1:", rc.query1(200))
    print("query2:", rc.query2(200))
    print("query3:", rc.query3()[:5], "...")  
    print("query4:", rc.query4())
    print("query5:", rc.query5())


    #rc._r.flushdb() # run only if necessary scientist
